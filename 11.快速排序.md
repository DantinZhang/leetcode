# 11. 快速排序

1、先选取枢纽，这里选择第一个元素为枢纽（其实选择首尾和中间位置元素三者的中位数比较好，方法就是先把三个数取出来冒泡排序，然后找到中位数作为枢纽pivot）

2、定义左右两个指针，依次和枢纽比较，如果左边比枢纽大，左指针停，否则右移；如果右边比枢纽小，右指针停，否则向左移动；然后左右指针位置的数进行交换，直到左右指针相撞，那么所指位置的数就和枢纽交换。本次排序就完成了。

3、接下来递归调用，分别对枢纽左侧和枢纽右侧重复执行上述操作，直到满足某个条件开始出栈，最后返回arr

4、递归停止的条件：begin == end 此时说明枢纽左侧或右侧只有一个元素，不需要排序；还有begin > end 此时说明枢纽在第一个元素（begin=1, end=-1），枢纽左侧没东西了不需要递归了，左侧就出栈

```javascript
function quickSort(arr, begin = 0, end = arr.length - 1) {
    if (begin >= end) return; //递归开始出栈的条件
    let i = begin; //定义一个左指针，指向第一个元素
    let j = end; //定义一个右指针，指向最后一个元素
    let pivot = arr[i]; //把枢纽设置为第一个元素
    //当左右指针重合（i==j）时，交换当前指针元素和枢纽位置元素
    while (i < j) {
        //只要没有重合，就继续迭代指针
        //先看右指针，如果右指针指向的数比pivot大，说明是正确的，继续向左查找
        while (i < j && arr[j] >= pivot) {
            //上面条件中，i < j 是为了防止指针迭代时i超过j，这是不对的
            j--;
        }
        //再看左指针，如果左指针指向的数比pivot小，说明是正确的，继续向右查找
        while (i < j && arr[i] <= pivot) {
            i++;
        }
        //左右指针都停了，就交换两个指针的数
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    //指针碰撞，交换枢纽(我们设置的是begin位置)和当前位置
    [arr[begin], arr[i]] = [arr[i], arr[begin]];
    //🆗，第一次排序结束，接下来左右分别递归
    quickSort(arr, begin, i - 1); //左边递归，确定起始结束位置
    quickSort(arr, i + 1, end); //右边递归，确定起始结束位置
}
```
